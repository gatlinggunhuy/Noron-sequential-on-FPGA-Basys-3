
`timescale 1ns / 1ps

// UART Receiver Module
module uart_rx (
    input  wire        clk,
    input  wire        rx_serial,
    output reg [7:0]   rx_byte,
    output reg         rx_done
);
    parameter CLK_FREQ    = 100_000_000;
    parameter BAUD_RATE   = 115200;
    localparam SAMPLE_CNT = CLK_FREQ / BAUD_RATE;

    reg [3:0]  state      = 0;
    reg [15:0] counter    = 0;
    reg [2:0]  bit_index  = 0;
    reg [7:0]  data       = 0;

    always @(posedge clk) begin
        case (state)
            0: if (!rx_serial) begin
                   state   <= 1;
                   counter <= 0;
               end
            1: if (counter == SAMPLE_CNT/2) begin
                   state      <= 2;
                   bit_index  <= 0;
                   counter    <= 0;
               end else counter <= counter + 1;
            2: if (counter == SAMPLE_CNT) begin
                   data[bit_index] <= rx_serial;
                   counter         <= 0;
                   bit_index       <= bit_index + 1;
                   if (bit_index == 7) state <= 3;
               end else counter <= counter + 1;
            3: if (counter == SAMPLE_CNT) begin
                   rx_byte <= data;
                   rx_done <= 1;
                   state   <= 0;
                   counter <= 0;
               end else counter <= counter + 1;
        endcase
        if (state == 0) rx_done <= 0;
    end
endmodule

// UART Transmitter Module
module uart_tx (
    input  wire        clk,
    input  wire [7:0]  tx_byte,
    input  wire        tx_start,
    output reg         tx_serial,
    output reg         tx_ready
);
    parameter CLK_FREQ  = 100_000_000;
    parameter BAUD_RATE = 115200;
    localparam BIT_PERIOD = CLK_FREQ / BAUD_RATE;

    reg [3:0]  state     = 0;
    reg [15:0] counter   = 0;
    reg [2:0]  bit_index = 0;
    reg [7:0]  data      = 0;

    initial begin
        tx_ready = 1;
    end

    always @(posedge clk) begin
        case (state)
            0: if (tx_start) begin
                   data       <= tx_byte;
                   tx_serial  <= 0;
                   counter    <= 0;
                   bit_index  <= 0;
                   state      <= 1;
                   tx_ready   <= 0;
               end
            1: if (counter == BIT_PERIOD) begin
                   tx_serial <= data[bit_index];
                   counter   <= 0;
                   bit_index <= bit_index + 1;
                   if (bit_index == 7) state <= 2;
               end else counter <= counter + 1;
            2: if (counter == BIT_PERIOD) begin
                   tx_serial <= 1;
                   counter   <= 0;
                   state     <= 0;
                   tx_ready  <= 1;
               end else counter <= counter + 1;
        endcase
    end
endmodule

// Fully Connected Layer Module (Serialized Computation)
module fully_connected #(
    parameter INPUT_SIZE  = 1024,
    parameter OUTPUT_SIZE = 3,
    parameter DATA_WIDTH  = 8
)(
    input  wire                      clk,
    input  wire                      rst,
    input  wire                      start,
    input  wire [INPUT_SIZE*DATA_WIDTH-1:0] input_data_flat,
    output reg  [OUTPUT_SIZE*DATA_WIDTH-1:0] output_data_flat,
    output reg                       done,
    output wire [10:0] debug_i,
    output wire [10:0] debug_j,
    output wire [1:0]  debug_state
);
    localparam TOTAL_WEIGHTS = OUTPUT_SIZE * INPUT_SIZE; // Số giá trị 8-bit
    reg [DATA_WIDTH-1:0] weights_flat [0:TOTAL_WEIGHTS-1]; // Mảng 1D unpacked
    reg [DATA_WIDTH-1:0] biases_flat [0:OUTPUT_SIZE-1];   // Mảng 1D unpacked
    reg [10:0] i, j;
    reg [31:0] temp [0:OUTPUT_SIZE-1];
    reg [31:0] mult_result;
    reg [1:0] state;

    localparam IDLE = 2'd0, COMPUTE = 2'd1, FINISH = 2'd2;

    // Đọc trọng số và thiên vị từ file hex
    initial begin
        $readmemh("mem/weights_hex.txt", weights_flat);
        $readmemh("mem/biases_hex.txt", biases_flat);
    end

    always @(posedge clk) begin
        if (rst) begin
            for (i = 0; i < OUTPUT_SIZE; i = i + 1) begin
                temp[i] <= 0;
            end
            output_data_flat <= 0;
            state <= IDLE;
            done <= 0;
            i <= 0;
            j <= 0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                    if (start) begin
                        state <= COMPUTE;
                        i <= 0;
                        j <= 0;
                        for (i = 0; i < OUTPUT_SIZE; i = i + 1) begin
                            temp[i] <= {24'b0, biases_flat[i]};
                        end
                    end
                end
                COMPUTE: begin
                    mult_result <= input_data_flat[j*DATA_WIDTH +: DATA_WIDTH] * 
                                   weights_flat[i*INPUT_SIZE + j];
                    temp[i] <= temp[i] + mult_result;

                    if (j == INPUT_SIZE-1) begin
                        j <= 0;
                        if (i == OUTPUT_SIZE-1) begin
                            state <= FINISH;
                        end else begin
                            i <= i + 1;
                        end
                    end else begin
                        j <= j + 1;
                    end
                end
                FINISH: begin
                    for (i = 0; i < OUTPUT_SIZE; i = i + 1) begin
                        output_data_flat[i*DATA_WIDTH +: DATA_WIDTH] <= temp[i][7:0];
                    end
                    done <= 1;
                    state <= IDLE;
                end
            endcase
        end
    end

    assign debug_i = i;
    assign debug_j = j;
    assign debug_state = state;
endmodule

// Top Module for Basys3
module top (
    input  wire clk,
    input  wire rx_serial,
    output wire tx_serial,
    output wire [7:0] debug_tx_data,
    output wire [2:0] debug_send_index,
    output wire debug_fc_done,
    output wire [2:0] debug_state,
    output wire [10:0] debug_fc_i,
    output wire [10:0] debug_fc_j,
    output wire [1:0] debug_fc_state
);
    parameter CLK_FREQ    = 100_000_000;
    parameter BAUD_RATE   = 115200;
    localparam BIT_PERIOD = CLK_FREQ / BAUD_RATE;

    parameter INPUT_SIZE  = 1024;
    parameter OUTPUT_SIZE = 3;
    parameter DATA_WIDTH  = 8;

    wire [7:0] rx_data;
    wire       rx_done;
    reg        tx_start;
    wire       tx_ready;
    reg  [7:0] tx_data;

    reg [7:0] image_buffer [0:INPUT_SIZE-1];
    reg [10:0] buffer_index;

    wire [INPUT_SIZE*DATA_WIDTH-1:0] input_data_flat;
    genvar k;
    generate
        for (k = 0; k < INPUT_SIZE; k = k + 1) begin : GEN_FLAT
            assign input_data_flat[k*DATA_WIDTH +: DATA_WIDTH] = image_buffer[k];
        end
    endgenerate

    wire [OUTPUT_SIZE*DATA_WIDTH-1:0] output_data_flat;
    wire fc_done;
    wire [10:0] fc_i, fc_j;
    wire [1:0] fc_state;
    reg  fc_start;

    wire rst;
    reg rst_reg = 1;
    assign rst = rst_reg;

    // Logic để tìm lớp có giá trị lớn nhất
    reg [7:0] max_value;
    reg [1:0] max_index;
    reg [1:0] compare_idx;

    always @(posedge clk) begin
        if (rst) begin
            rst_reg <= 0;
        end
    end

    uart_rx #( .CLK_FREQ(CLK_FREQ), .BAUD_RATE(BAUD_RATE) ) uart_rx_inst (
        .clk(clk), .rx_serial(rx_serial), .rx_byte(rx_data), .rx_done(rx_done)
    );

    uart_tx #( .CLK_FREQ(CLK_FREQ), .BAUD_RATE(BAUD_RATE) ) uart_tx_inst (
        .clk(clk), .tx_byte(tx_data), .tx_start(tx_start), .tx_serial(tx_serial), .tx_ready(tx_ready)
    );

    fully_connected #(
        .INPUT_SIZE(INPUT_SIZE), .OUTPUT_SIZE(OUTPUT_SIZE), .DATA_WIDTH(DATA_WIDTH)
    ) fc_inst (
        .clk(clk), .rst(rst), .start(fc_start),
        .input_data_flat(input_data_flat),
        .output_data_flat(output_data_flat),
        .done(fc_done),
        .debug_i(fc_i),
        .debug_j(fc_j),
        .debug_state(fc_state)
    );

    localparam IDLE = 3'd0, RECEIVING = 3'd1, COMPUTING = 3'd2, COMPARE = 3'd3, SENDING = 3'd4, WAIT_TX = 3'd5;
    reg [2:0] state;
    reg [15:0] delay_cnt;
    reg [2:0] send_index;

    initial begin 
        state = IDLE; 
        buffer_index = 0; 
        tx_start = 0; 
        send_index = 0; 
        delay_cnt = 0;
        fc_start = 0;
        max_value = 0;
        max_index = 0;
        compare_idx = 0;
    end

    always @(posedge clk) begin
        case (state)
            IDLE: if (rx_done) begin
                buffer_index <= 0;
                state <= RECEIVING;
                tx_start <= 0;
                send_index <= 0;
                fc_start <= 0;
            end
            RECEIVING: begin
                if (rx_done) begin
                    image_buffer[buffer_index] <= rx_data;
                    if (buffer_index == INPUT_SIZE-1) begin
                        state <= COMPUTING;
                        fc_start <= 1;
                    end else begin
                        buffer_index <= buffer_index + 1;
                    end
                end
            end
            COMPUTING: begin
                fc_start <= 0;
                if (fc_done) begin
                    delay_cnt <= 0;
                    send_index <= 0;
                    compare_idx <= 0;
                    max_value <= 0;
                    max_index <= 0;
                    state <= COMPARE;
                end
            end
            COMPARE: begin
                if (output_data_flat[compare_idx*DATA_WIDTH +: DATA_WIDTH] > max_value) begin
                    max_value <= output_data_flat[compare_idx*DATA_WIDTH +: DATA_WIDTH];
                    max_index <= compare_idx;
                end
                if (compare_idx == OUTPUT_SIZE-1) begin
                    state <= SENDING;
                end else begin
                    compare_idx <= compare_idx + 1;
                end
            end
            SENDING: begin
                if (delay_cnt < 1000) begin
                    delay_cnt <= delay_cnt + 1;
                end else if (!tx_start && tx_ready) begin
                    tx_data <= max_index; // Gửi chỉ số lớp lớn nhất
                    tx_start <= 1;
                    state <= WAIT_TX;
                end
            end
            WAIT_TX: begin
                if (!tx_ready) begin
                    tx_start <= 0;
                    state <= IDLE;
                end
            end
        endcase
    end

    assign debug_tx_data = tx_data;
    assign debug_send_index = send_index;
    assign debug_fc_done = fc_done;
    assign debug_state = state;
    assign debug_fc_i = fc_i;
    assign debug_fc_j = fc_j;
    assign debug_fc_state = fc_state;
endmodule

